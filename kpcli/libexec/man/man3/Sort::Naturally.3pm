.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Sort::Naturally 3"
.TH Sort::Naturally 3 "2012-04-11" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Sort::Naturally \-\- sort lexically, but sort numeral parts numerically
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  @them = nsort(qw(
\&   foo12a foo12z foo13a foo 14 9x foo12 fooa foolio Foolio Foo12a
\&  ));
\&  print join(\*(Aq \*(Aq, @them), "\en";
.Ve
.PP
Prints:
.PP
.Vb 1
\&  9x 14 foo fooa foolio Foolio foo12 foo12a Foo12a foo12z foo13a
.Ve
.PP
(Or \*(L"foo12a\*(R" + \*(L"Foo12a\*(R" and \*(L"foolio\*(R" + \*(L"Foolio\*(R" and might be
switched, depending on your locale.)
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module exports two functions, \f(CW\*(C`nsort\*(C'\fR and \f(CW\*(C`ncmp\*(C'\fR; they are used
in implementing my idea of a \*(L"natural sorting\*(R" algorithm.  Under natural
sorting, numeric substrings are compared numerically, and other
word-characters are compared lexically.
.PP
This is the way I define natural sorting:
.IP "\(bu" 4
Non-numeric word-character substrings are sorted lexically,
case-insensitively: \*(L"Foo\*(R" comes between \*(L"fish\*(R" and \*(L"fowl\*(R".
.IP "\(bu" 4
Numeric substrings are sorted numerically:
\&\*(L"100\*(R" comes after \*(L"20\*(R", not before.
.IP "\(bu" 4
\&\eW substrings (neither words-characters nor digits) are \fIignored\fR.
.IP "\(bu" 4
Our use of \ew, \ed, \eD, and \eW is locale-sensitive:  Sort::Naturally
uses a \f(CW\*(C`use locale\*(C'\fR statement.
.IP "\(bu" 4
When comparing two strings, where a numeric substring in one
place is \fInot\fR up against a numeric substring in another,
the non-numeric always comes first.  This is fudged by
reading pretending that the lack of a number substring has
the value \-1, like so:
.Sp
.Vb 4
\&  foo       =>  "foo",  \-1
\&  foobar    =>  "foo",  \-1,  "bar"
\&  foo13     =>  "foo",  13,
\&  foo13xyz  =>  "foo",  13,  "xyz"
.Ve
.Sp
That's so that \*(L"foo\*(R" will come before \*(L"foo13\*(R", which will come
before \*(L"foobar\*(R".
.IP "\(bu" 4
The start of a string is exceptional: leading non\-\eW (non-word,
non-digit)
components are are ignored, and numbers come \fIbefore\fR letters.
.IP "\(bu" 4
I define \*(L"numeric substring\*(R" just as sequences matching m/\ed+/ \*(--
scientific notation, commas, decimals, etc., are not seen.  If
your data has thousands separators in numbers
(\*(L"20,000 Leagues Under The Sea\*(R" or \*(L"20.000 lieues sous les mers\*(R"),
consider stripping them before feeding them to \f(CW\*(C`nsort\*(C'\fR or
\&\f(CW\*(C`ncmp\*(C'\fR.
.SS "The nsort function"
.IX Subsection "The nsort function"
This function takes a list of strings, and returns a copy of the list,
sorted.
.PP
This is what most people will want to use:
.PP
.Vb 1
\&  @stuff = nsort(...list...);
.Ve
.PP
When nsort needs to compare non-numeric substrings, it
uses Perl's \f(CW\*(C`lc\*(C'\fR function in scope of a <use locale>.
And when nsort needs to lowercase things, it uses Perl's
\&\f(CW\*(C`lc\*(C'\fR function in scope of a <use locale>.  If you want nsort
to use other functions instead, you can specify them in
an arrayref as the first argument to nsort:
.PP
.Vb 6
\&  @stuff = nsort( [
\&                    \e&string_comparator,   # optional
\&                    \e&lowercaser_function  # optional
\&                  ],
\&                  ...list...
\&                );
.Ve
.PP
If you want to specify a string comparator but no lowercaser,
then the options list is \f(CW\*(C`[\e&comparator, \*(Aq\*(Aq]\*(C'\fR or
\&\f(CW\*(C`[\e&comparator]\*(C'\fR.  If you want to specify no string comparator
but a lowercaser, then the options list is
\&\f(CW\*(C`[\*(Aq\*(Aq, \e&lowercaser]\*(C'\fR.
.PP
Any comparator you specify is called as
\&\f(CW\*(C`$comparator\->($left, $right)\*(C'\fR,
and, like a normal Perl \f(CW\*(C`cmp\*(C'\fR replacement, must return
\&\-1, 0, or 1 depending on whether the left argument is stringwise
less than, equal to, or greater than the right argument.
.PP
Any lowercaser function you specify is called as
\&\f(CW\*(C`$lowercased = $lowercaser\->($original)\*(C'\fR.  The routine
must not modify its \f(CW$_[0]\fR.
.SS "The ncmp function"
.IX Subsection "The ncmp function"
Often, when sorting non-string values like this:
.PP
.Vb 1
\&   @objects_sorted = sort { $a\->tag cmp $b\->tag } @objects;
.Ve
.PP
\&...or even in a Schwartzian transform, like this:
.PP
.Vb 6
\&   @strings =
\&     map $_\->[0]
\&     sort { $a\->[1] cmp $b\->[1] }
\&     map { [$_, make_a_sort_key_from($_) ]
\&     @_
\&   ;
.Ve
.PP
\&...you wight want something that replaces not \f(CW\*(C`sort\*(C'\fR, but \f(CW\*(C`cmp\*(C'\fR.
That's what Sort::Naturally's \f(CW\*(C`ncmp\*(C'\fR function is for.  Call it with
the syntax \f(CW\*(C`ncmp($left,$right)\*(C'\fR instead of \f(CW\*(C`$left cmp $right\*(C'\fR,
but otherwise it's a fine replacement:
.PP
.Vb 1
\&   @objects_sorted = sort { ncmp($a\->tag,$b\->tag) } @objects;
\&
\&   @strings =
\&     map $_\->[0]
\&     sort { ncmp($a\->[1], $b\->[1]) }
\&     map { [$_, make_a_sort_key_from($_) ]
\&     @_
\&   ;
.Ve
.PP
Just as with \f(CW\*(C`nsort\*(C'\fR can take different a string-comparator
and/or lowercaser, you can do the same with \f(CW\*(C`ncmp\*(C'\fR, by passing
an arrayref as the first argument:
.PP
.Vb 6
\&  ncmp( [
\&          \e&string_comparator,   # optional
\&          \e&lowercaser_function  # optional
\&        ],
\&        $left, $right
\&      )
.Ve
.PP
You might get string comparators from Sort::ArbBiLex.
.SH "NOTES"
.IX Header "NOTES"
.IP "\(bu" 4
This module is not a substitute for
Sort::Versions!  If
you just need proper version sorting, use \fIthat!\fR
.IP "\(bu" 4
If you need something that works \fIsort of\fR like this module's
functions, but not quite the same, consider scouting thru this
module's source code, and adapting what you see.  Besides
the functions that actually compile in this module, after the \s-1POD,\s0
there's several alternate attempts of mine at natural sorting
routines, which are not compiled as part of the module, but which you
might find useful.  They should all be \fIworking\fR implementations of
slightly different algorithms
(all of them based on Martin Pool's \f(CW\*(C`nsort\*(C'\fR) which I eventually
discarded in favor of my algorithm.  If you are having to
naturally-sort \fIvery large\fR data sets, and sorting is getting
ridiculously slow, you might consider trying one of those
discarded functions \*(-- I have a feeling they might be faster on
large data sets.  Benchmark them on your data and see.  (Unless
you \fIneed\fR the speed, don't bother.  Hint: substitute \f(CW\*(C`sort\*(C'\fR
for \f(CW\*(C`nsort\*(C'\fR in your code, and unless your program speeds up
drastically, it's not the sorting that's slowing things down.
But if it \fIis\fR \f(CW\*(C`nsort\*(C'\fR that's slowing things down, consider
just:
.Sp
.Vb 10
\&      if(@set >= SOME_VERY_BIG_NUMBER) {
\&        no locale; # vroom vroom
\&        @sorted = sort(@set);  # feh, good enough
\&      } elsif(@set >= SOME_BIG_NUMBER) {
\&        use locale;
\&        @sorted = sort(@set);  # feh, good enough
\&      } else {
\&        # but keep it pretty for normal cases
\&        @sorted = nsort(@set);
\&      }
.Ve
.IP "\(bu" 4
If you do adapt the routines in this module, email me; I'd
just be interested in hearing about it.
.IP "\(bu" 4
Thanks to the EFNet #perl people for encouraging this module,
especially magister and a\-mused.
.SH "COPYRIGHT AND DISCLAIMER"
.IX Header "COPYRIGHT AND DISCLAIMER"
Copyright 2001, Sean M. Burke \f(CW\*(C`sburke@cpan.org\*(C'\fR, all rights
reserved.  This program is free software; you can redistribute it
and/or modify it under the same terms as Perl itself.
.PP
This program is distributed in the hope that it will be useful, but
without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sean M. Burke \f(CW\*(C`sburke@cpan.org\*(C'\fR
